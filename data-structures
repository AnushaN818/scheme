"STACK"
(define (make-stack)
 (let ((S '()))
 (define (empty?) (null? S))
 (define (top) (car S))
 (define (pop) (let ((top (car S)))
 (begin (set! S (cdr S))
 top)))
 (define (push x) (set! S (cons x S)))
 (define (dispatcher method)
 (cond ((eq? method 'top) top)
 ((eq? method 'pop) pop)
 ((eq? method 'push) push)
 ((eq? method 'empty) empty?)))
 dispatcher))

(define (eval-postfix p)
  (let ((stck (make-stack)))
    (define (helper operand)
      (cond ((eq? operand #\+)
             ((stck 'push)
              (+ ((stck 'pop))
                 ((stck 'pop)))))
            ((eq? operand #\-)
             ((stck 'push)
              (let ((m2 ((stck 'pop)))
                    (m1 ((stck 'pop))))
                (- p2 p1))))
            ((eq? operand #\*)
             ((stck 'push)
              (* ((stck 'pop))
                 ((stck 'pop)))))
            ((eq? operand #\/)
             ((stck 'push)
              (let ((d2 ((stck 'pop)))
                    (d1 ((stck 'pop))))
                (/ d2 d1))))
            ((eq? operand #\^)
             ((stck 'push)
              (let ((e2 ((stck 'pop)))
                    (e1 ((stck 'pop))))
                (expt e2 e1))
              )
             )
            )
      )
    (define (helper2)
      (cond ((null? p) ((stck 'top)))
            ((number? (car p))
             (begin ((stck 'push) (car p))
                    (set! p (cdr p))
                    (helper2)))
            (else (begin
                    (helper (car p))
                    (set! p (cdr p))
                    (helper2)))
            )
      )
    (begin (helper2)
           ((stck 'top))
           )
    )
  )
(eval-postfix '(47))

  (eval-postfix (list 23 15 (string-ref (symbol->string '+) 0)))
           

"TREE"
(define (make-tree value left right)
  (list value left right))
(define (value tree) (car tree))
(define (left tree) (cadr tree))
(define (right tree) (caddr tree))
(define empty-tree? null?)

"(define (treeToStack T)
  (let ((stck (make-stack)))
    (cond ((null? T)
           ((stck 'top)ai))
          ((and (null? (left T)) (null? (right T)))
           ((stck 'push) (value T)))
          ((and (null? (left T)) (not (null? (right T))))
           (begin
             ((stck 'push) (value T))
             (treeToStack (right T)))
           )
          ((and (not (null? (left T))) (null? (right T)))
           (begin
              ((stck 'push) (value T))
              (treeToStack (left T)))
           )
          (else
           (begin
             ((stck 'push) (value T))
             (treeToStack (left T))
             (treeToStack (right T))
             )
           )
          )
    )
    (helper T (make-stack))
    
  )"
(define (dfs T)
  (let ((stck (make-stack)))
    ((stck 'push) t)
    (define (helper lst)
      (if ((stck 'empty))
          lst
          (let ((treestack ((stck 'pop))))
            (cond ((not (null? treestack))
                   (begin ((stck 'push) (right treestack))
                          ((stck 'push) (left treestack))
                          (helper (append lst (list (value treestack))))))
                  (else (helper lst))
                  )
            )
          )
      )
    (helper '())
    ))

"QUEUE"
(define (make-queue)
 (let ((head '())
 (tail '()))
 (define (value n) (car n))
 (define (next n) (cdr n))
 (define (empty?) (null? head))
 (define (front) (value head))
 (define (enqueue x)
 (let ((new-node (cons x '())))
 (begin
 (if (empty?)
 (set! head new-node)
 (set-cdr! tail new-node))
 (set! tail new-node))))
 (define (dequeue)
 (let ((return (value head)))
 (if (eq? head tail)
 (begin (set! head '())
 (set! tail '())
 return)
 (begin (set! head (next head))
 return))))
 (define (dispatcher method)
 (cond ((eq? method 'empty) empty?)
 ((eq? method 'enqueue) enqueue)
 ((eq? method 'dequeue) dequeue)
 ((eq? method 'front) front)))
 dispatcher))

(define (bfs T)
  (let ((que (make-queue)))
    ((que 'enqueue) T)
    (define (helper lst)
      (if ((que 'empty))
          lst
          (let ((nque ((que 'dequeue))))
            (cond ((not (null? nque))
                   (begin
                     ((que 'enqueue) (left nque))
                     ((que 'enqueue) (right nque))
                     (helper (append lst (list (value nque))))
                     )
                   )
                  (else (helper lst))
                  )
            )
          )
      )
    (helper '())))
      
      
